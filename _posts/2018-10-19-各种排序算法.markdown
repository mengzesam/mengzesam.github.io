**各种排序算法**
  
  $e^{\pi{i}}+1=0$

- insert sort
  ```
    void insertSort(int A[],int n){
        for(int i=1;i<n;i++){
            int key=A[i];
            int j=i-1;
            while(j>=0 && key<A[j]){
                A[j+1]=A[j];
                j--;
            }
            A[j+1]=key;
        }
    }
  ```
- select sort
  ```
    void selectSort(int A[],int n){
        for(int i=0;i<n-1;i++){
            int k=i;
            for(int j=i+1;j<n;j++){
                if(A[j]<A[k])
                    k=j;
            }
            if(k!=i){
                int tmp=A[k];
                A[k]=A[i];
                A[i]=tmp;
            }
        }
    }
  ```
- bubble sort
  ```
    void bubbleSort(int A[],int n){
        for(int i=1;i<n;i++){
            int no_swapped=1;
            for(int j=n-1;j>=i;j--)
                if(A[j-1]>A[j]){
                    int tmp=A[j];
                    A[j]=A[j-1];
                    A[j-1]=tmp;
                    no_swapped=0;
                }
            if(no_swapped)
                break;
        }
    }
  ```
- quick sort
  ```
    int partition(itemType a[],int l,int r){
        ////TODO:相等元素的处理，避免O(n2);pivot选择随机数进行比较；
        //dualpivotquicksort（java jdk1.7库的sort研究）
        itemType pivot;
        if(r-l+1>=27){
            //三取中:
            int mid=l+(r-l)/2;
            if(a[mid]<a[l]){
                pivot=a[mid];
                a[mid]=a[l];
                a[l]=pivot;
            }
            if(a[r]<a[l]){
                pivot=a[r];
                a[r]=a[l];
                a[l]=pivot;
            }    
            if(a[mid]<a[r]){
                pivot=a[mid];
                a[mid]=a[r];
                a[r]=pivot;
            }
        }//三取中    
        pivot=a[r];
        int i=l-1;
        int j=l;
        while(j<r){
            if(cmp(a[j],pivot)){
                i++;
                //if(i!=j){
                    itemType tmp=a[i];
                    a[i]=a[j];
                    a[j]=tmp;
                //}
            }
            j++;
        }
        //if(i+1!=r){
            itemType tmp=a[i+1];
            a[i+1]=a[r];
            a[r]=tmp;
        //}
        return i+1;
    }
    void hybridQuickSort(itemType a[],int l,int r){
        if(r-l+1<=THRESHOLD){//THRESHOLD=12 or 16?
            insertSort(a,l,r);
            return;
        }
        while(l<r){
            int q=partition(a,l,r);
            hybridQuickSort(a,l,q-1);
            l=q+1;
        }
    }
  ```
- shell sort
  ```
    void shellSort2(int A[],int n){
        /*
            递增序列采用表格方式给出，其倒序为1，4，13，40，121，364...
            递增训练的构造还有其他，可参考
            http://www.cs.princeton.edu/~rs/shell/driver.c
            和
            http://www.cs.princeton.edu/~rs/shell/paperF.pdf
        */
        if(n<=1) return;
        int incs[]={1743392200,581130733,193710244,64570081,21523360,7174453,2391484,
                    797161,265720,88573,29524,9841,3280,1093,364,121,40,13,4,1};
        int k=0,r=19;
        while(k<=r){
            int mid=k+(r-k)/2;
            if(n>incs[mid])
                r=mid-1;
            else
                k=mid+1;
        }
        for(;k<20;k++){
            int h=incs[k];
            for(int i=h;i<n;i++){
                int key=A[i];
                int j=i-h;
                while(0<=j && key<A[j]){
                    A[j+h]=A[j];
                    j-=h;
                }
                A[j+h]=key;
            }
        }    
    }
```

